\documentclass[]{llncs} 
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{datatool}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes}
\usepackage{graphics}

\newcommand{\TODO}[1]{ {\color{red}{TODO: #1} }}
\newcommand{\com}[1]{ {\color{blue}{--- #1 ---}}}

\author{Valentin Mayer-Eichberger}

\institute{NICTA \\ University of New South Wales \\
\email{valentin.mayer-eichberger@nicta.com.au}}

\title{A SAT Encoding for the AtMostSeqCard Constraint}

\begin{document} \maketitle

\section{Introduction}

Give description of the car sequencing problem and the straight
forward encoding in IP/CNF. 

The naive CNF and IP encoding of the car sequencing benchmark is
far from optimal. In this paper we will show gradually how to come up
with a better encoding. 

\section{Motivation}

We are seeking an encoding that enforces GAC on the recently proposed
AtMostSeqCard constraint. This constraint is not as expressive as the
Sequence constraint but is more suited for some benchmark problems and
has a linear filtering algorithm. Here we will show that there is a
compact CNF encodings that shows good results in the benchmark set of
the CSPLIB. Furthermore we will try to improve the bounds on the set of
hard instance. 

\section{Encoding of one AtMostSeqCard}

We will first show how to encode a cardinality constraint with a counter
encoding (ref?) and then integrate the AtMostSeq by reusing the auxiliary
variables of the counter encoding. 

\subsection{Encoding of Counters}

Given a set of consecutive positions $P=\{0\ldots n\}$, an object (class
or option) $i$. Let $x_{i,j}$ be true iff object $i$ is assigned at
position $j$.  We want to encode the following cardinality constraint

$$ s = \sum_{j\in P} x_{i,j} $$

where $s$ is a fixed value.  We call the encoding for such a cardinality
constraint a counter encoding because we count exactly $s$ objects among
the positions $P$. 

So given an option or a class identified by subscript $i\in I$ that needs to be
counted over a period of time. Each step in time or position is denoted
by $j\in P$. We introduce the following variables: 

\begin{itemize}
    \item $y_{i,j,k}$ is true iff at least $k$ objects of type $i$ have been
        assigned until position $j$. 
\end{itemize}

Notice that we assume the set $P$ to have a total ordering. We count
along this ordering. The following formula clearifies the relationship
between $x$ and $y$.

$$ y_{i,j,k} \iff (k \leq \sum_{l=0}^{j} x_{i,l}) $$


\begin{figure}
\centering 
\caption{The variables $y_{i,j,k}$ for a countable object $i$ with an
upper bound of two over a sequence of 10. The variables corresponding to
the cells containing $U$($L$) are set to false (true). The question mark
identifies a unassigned variable of the counter encoding}
\begin{tikzpicture}
\node [matrix,ampersand replacement=\&,nodes={minimum size=6mm}]
%,nodes={fill=blue!20,minimum size=5mm}] 
    {
        \node {3}; \& \node (x) { }; \& \node { }; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \\
        \node {2}; \& \node { }; \& \node {U}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {L}; \\
        \node {1}; \& \node {U}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {?}; \& \node {L}; \& \node { }; \\
        \node {0}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node { }; \& \node (y) { }; \\
        \node {k/j}; \& \node {0}; \& \node {1}; \& \node {2}; \& \node {3}; \& \node {4}; \& \node {5}; \& \node {6}; \& \node {7}; \& \node {8}; \& \node {9}; \& \node {10}; \\
};
\draw[gray] (x.north west) rectangle (y.south east);
\end{tikzpicture}
\end{figure}

There are two types of binay clauses that relate the variables
$y_{i,j,k}$ and two types of tenery clauses that coordinate $y_{i,j,k}$
with the variables $x_{i,j}$.

\begin{equation}
    \bigwedge_{\substack{j \in P \\ j+1\in P}} \bigwedge_{k\in\{1..s\}}
    \neg y_{i,j,k} \vee y_{i,j+1,k}
\end{equation}

\begin{equation}
    \bigwedge_{\substack{j \in P \\ j-1\in P}} \bigwedge_{k,k-1\in\{1..s\}}
    \neg y_{i,j,k} \vee y_{i,j-1,k-1}
\end{equation}

These clauses restrict the structure of the auxiliary variables to
consist of a counter. Now we need to relate these variables to $x$. 
First we define clauses that consist of pushing the counter up. 

\begin{equation}
    \bigwedge_{\substack{j \in P \\ j+1\in P}} \bigwedge_{k,k+1\in\{0..s+1\}}
    \neg x_{i,j} \vee \neg y_{i,j,k} \vee y_{i,j+1,k+1}
\end{equation}

And now we have to restrict the counter to be pushed up if $x_{i,j}$ is
false. 

\begin{equation}
    \bigwedge_{\substack{j \in P \\ j+1\in P}} \bigwedge_{k,k+1\in\{1..s+1\}}
    \neg x_{i,j} \vee \neg y_{i,j,k} \vee y_{i,j+1,k+1}
\end{equation}



\begin{figure}
\centering 
\caption{Taking the previous example and let $x_{i,j}$ be true for
    position 2 and 7. Then the resulting assignment to the counter
    variable is given in this table. }
\begin{tikzpicture}
\node [matrix,ampersand replacement=\&,nodes={minimum size=6mm}]
%,nodes={fill=blue!20,minimum size=5mm}] 
    {
        \node {3}; \& \node (x) { }; \& \node { }; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \& \node {U}; \\
        \node {2}; \& \node { }; \& \node {U}; \& \node {0}; \& \node {0}; \& \node {0}; \& \node {0}; \& \node {0}; \& \node {1}; \& \node {1}; \& \node {1}; \& \node {L}; \\
        \node {1}; \& \node {U}; \& \node {0}; \& \node {1}; \& \node {1}; \& \node {1}; \& \node {1}; \& \node {1}; \& \node {1}; \& \node {1}; \& \node {L}; \& \node { }; \\
        \node {0}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node {L}; \& \node { }; \& \node (y) { }; \\
        \node {k/j}; \& \node {0}; \& \node {1}; \& \node {2}; \& \node {3}; \& \node {4}; \& \node {5}; \& \node {6}; \& \node {7}; \& \node {8}; \& \node {9}; \& \node {10}; \\
};
\draw[gray] (x.north west) rectangle (y.south east);
\end{tikzpicture}
\end{figure}

\subsection{Extending to AtMostSeqCard}

Let $i$ be an option:

$$ \text{AtMostSeqCard}(u,q,d,[x_1,\ldots,x_n]) \iff
\bigwedge_{i=0}^{n-q}(\sum_{l=1}^q x_{i+l} \leq u ) \wedge (\sum_{i=1}^n
x_i = d) $$


\section{Encoding of Carsequencing}

We need to relate the cars and options as in the problem specification.
This can be done in two ways. First the straight forward way. 

\subsection{Relating Cars and Option directly}

Let $c \in C$ be the index identifying a class and $o\in O $ be the
index for options. The problem instance gives us a mapping $m :
C\rightarrow 2^O$, relating to each class a set of options. 

\begin{equation}
    \bigwedge_{p\in P} \bigwedge_{\substack{c \in C \\ o \in m(c)}}
    \neg x_{c,p} \vee x_{o,p}
\end{equation}

and the reverse

\begin{equation}
    \bigwedge_{p\in P} (\neg x_{o,p} \vee \bigvee_{\substack{c \in C \\
    o \in m(c)}} x_{c,p})
\end{equation}

Notice in an ASP encoding this would be modelled by one rule and the
completion semantics is equivalent to this encoding. 

\subsection{The Purist's Way}

Here we will show that there is an encoding of the car sequencing
problem that does not use at all the variables $x_{i,j}$. The encoding
builds entirely on the auxiliary variables and can consistently identify
all solutions to this problem. This is rather surprising. Here the idea: 

\section{Evaluation}

Best of results that can be robustly (standard heuristics) archived by
current sat solvers. I compared newest version of minisat, lingeling,
cryptominisat, glucose and clasp and they all consistently find
solutions within 1h runtime. 

\DTLsetseparator{,}
\DTLloaddb[keys={res,set1,set2,set3,set4}]{results}{results.csv}

\begin{table}[htbp]
    \caption{}
    \centering
    \DTLdisplaydb{results}
\end{table}


This is by far better than most papers evaluating the car sequencing
problem on some specialized algorithm (e.g. branch and bound) or special
constraint (CP) or optimization (IP). 

For the set 4 a more detailed view is interesting as the benchmark
targets the optimization version of the car sequencing problem. 

\DTLsetseparator{,}
\DTLloaddb[keys={instance,ip,sat}]{set4}{set4.csv}

\begin{table}[htbp]
    \caption{Solutions to the proposed hard benchmark on the 2004 paper
    (IP) and solutions on the decision version on the SAT encoding
(SAT). }
    \centering
    \DTLdisplaydb{set4}
\end{table}


We can solve all 7 satisfiable instances and prove 13/23 instances to be
unsatisfiable. 


\section{Extensions}

\begin{itemize}
    \item Optimizations: there are two definitions of the cost function
        for the car sequencing problem. First is to allow arbirary cars
        without any options and minimize the number of cars with
        options. And second is to minimize the number of windows that
        exceed the capacity constraint on their options. It would be
        interesting to compare both definition and to evaluate against
        published results in the literature. There are still gaps
        between known upper and lower bounds. 
    \item There is a natural extension of the AtMostSeqCard constraint
        that to a cyclic version and in the same and natural way we can
        extend the encoding given above. It would be interesting to find
        good benchmarks. 
    \item The Sequence constraint consists of a sequence of among
        constraints and we should compare this encoding to the known CNF
        encodings and filtering algorithmsin the literature. 
\end{itemize}




\end{document}
