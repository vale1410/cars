First, we would like to thank the reviewers for their comments.

Review1

*The cardinality of I in w_S^k is the number of variables in I assigned to 1
*The explanation is not optimal. We have examples but we did not include
them for lack of space
*Minisat [Section6]: We generate one atmostseqcard for each class and each
option. The demand is given by the problem description for the classes, and
implicitly for the options. For the classes we may choose one (or more)
capacity restriction of its options as they directly apply. In the SAT model
we choose for each class the capacity constraint with minimal value (u/q),
i.e.  the strictest. 
*we used restarts for all approaches 
*we update the usage rates dynamically. 

Review2

*Different encodings of cardinality constraints. Regarding SCA (AtMost for
each subsequence) we do not expect improvements wrt. the benchmarks. The
maximal restriction is 2/5 and too short to make use of different
cardinality encodings. In fact we tried encodings that do not use auxiliary
variables for these constraints (posting all prime implicates is possible
for small values) and did not experience great difference.
*Regarding the cardinality on the global demand for options and classes, it
is indeed interesting to compare it to the recent advances; by using
minisat+ we show indirectly alternative encodings of cardinality as minisat+
automatically translates by sorting networks (or BDDs). We see advantage in
the SCS encoding as we can reuse the auxiliary variables, something that
would not work for the sorting networks. There is future work in trying
other SAT encodings.
*The experiments were done on the same machine.

Review3
*CP + nogoods generated by the new explanations were in fact tested (denoted
"hybrid"). The current version of Mistral actually handles clause learning
on SAT and pseudo-Boolean instances (i.e. it implements all standards
features of CDCL).
*The reviewer points out in detail the  similarities and differences to [2].
However, at the end of the day, our approach is different. We introduce our
encoding by an extension of a sequential counter and thus we miss to show
the proximity to the encoding of regular/gen-sequence. 
Whilst we accept this criticism and will revise the paper, we believe that
the SAT encodings add novelty and are worth reporting.
- By focusing on a special case (AtMostSeqCard) of gen-sequence we can point
out the explicit encoding and show special properties.
- There are three differences to [2] (as mentioned by the reviewer).
1) Using the >=d semantics for the auxiliary variables, branching becomes
more fine-grained and less "committing" than for =d semantics.
2) On the auxiliary variables we gain increased propagation due to the
additional binary clauses. 1) and 2) are related to the comparison of
"direct encoding" vs. "order encoding".
3) In E3 we encode both the SCS encoding together with SCA for each capacity
constraint and we show that this archives GAC by reducing to a Lemma for the
CP propagator.
*The explanation is not optimal. We will clarify this point.

