package main

import (
	"../base"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"regexp"
	"strconv"
	"strings"
)

var sol = flag.String("sol", "sol.txt", "Solution of a SAT solver; contains lines starting with s and model")
var sym = flag.String("sym", "symbols.txt", "Symbol file, must have syntax of the file generated by the encoder.")

var digitRegexp = regexp.MustCompile("([0-9]+ )*[0-9]+")

func main() {
	flag.Parse()
	if *ver {
		fmt.Println(`CNF Decoder for solutions of the car sequencing problem from CSPLib 
Version tag: 0.1a
For infos about flags use -help
Copyright (C) NICTA and Valentin Mayer-Eichberger
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>
There is NO WARRANTY, to the extent permitted by law.`)
		return
	}

    // parse syntax file

    // parse solution

    // parse solution

}
type IdGen struct {
	Id           int
	CountVarMap  map[base.CountVar]int
	PosVarMap    map[base.PosVar]int
	AtMostVarMap map[base.AtMostVar]int
}

func NewIdGen() {
	gen.Id = 0
	gen.PosVarMap = make(map[base.PosVar]int, size*(class_count+option_count)) //just an approximation of size of map
	gen.CountVarMap = make(map[base.CountVar]int, size*class_count^2)          //just an approximation of size of map  
	gen.AtMostVarMap = make(map[base.AtMostVar]int, size*class_count^2)        //just an approximation of size of map
	return
}

func parseSymboltable(filename string) () {
	input, err := ioutil.ReadFile(filename)

	if err != nil {
		fmt.Println("Please specifiy correct path to symboltable. File does not exist: ", filename)
		return
	}

	b := bytes.NewBuffer(input)

	lines := strings.Split(b.String(), "\n")

	state := 0

	for _, l := range lines {
		numbers := strings.Split(strings.TrimSpace(l), " ")
		if digitRegexp.MatchString(numbers[0]) {
			switch state {
			case 0:
				{
					size, _ = strconv.Atoi(numbers[0])
					option_count, _ = strconv.Atoi(numbers[1])
					options = make([]base.Countable, option_count)
					class_count, _ = strconv.Atoi(numbers[2])
					classes = make([]base.Countable, class_count)
					class2option = make([][]bool, class_count)
				}
			case 1:
				{
					for i, v := range numbers {
						capacity, _ := strconv.Atoi(v)
						options[i].CId = base.CountableId{base.OptionType, i}
						options[i].Capacity = capacity
					}
				}
			case 2:
				{
					for i, v := range numbers {
						window, _ := strconv.Atoi(v)
						options[i].Window = window
					}
				}
			default:
				{
					num, _ := strconv.Atoi(numbers[0])
					classes[num].CId = base.CountableId{base.ClassType, num}
					class2option[num] = make([]bool, option_count)

					// find option with lowest slope
					// to determine capacity and windows

					classes[num].Capacity = 1
					classes[num].Window = 1
					slope := 1.0

					for i, v := range numbers {
						if i == 1 {
							demand, _ := strconv.Atoi(v)
							classes[num].Demand = demand
						} else if i > 1 {
							value, _ := strconv.Atoi(v)
							has_option := value == 1
							class2option[num][i-2] = has_option
							if has_option {
								options[i-2].Demand += classes[num].Demand
								slope2 := float64(options[i-2].Capacity) / float64(options[i-2].Window)
								if slope2 < slope {
									slope = slope2
									classes[num].Capacity = options[i-2].Capacity
									classes[num].Window = options[i-2].Window
								}
							}
						}
					}
				}
			}
			state++
		} else {
			//fmt.Println("c ", l)
		}
	}
	return

}

func parseSymboltable(filename string) () {
	input, err := ioutil.ReadFile(filename)

	if err != nil {
		fmt.Println("Please specifiy correct path to symboltable. File does not exist: ", filename)
		return
	}

	b := bytes.NewBuffer(input)

	lines := strings.Split(b.String(), "\n")

	state := 0

	for _, l := range lines {
		numbers := strings.Split(strings.TrimSpace(l), " ")
		if digitRegexp.MatchString(numbers[0]) {
			switch state {
			case 0:
				{
					size, _ = strconv.Atoi(numbers[0])
					option_count, _ = strconv.Atoi(numbers[1])
					options = make([]base.Countable, option_count)
					class_count, _ = strconv.Atoi(numbers[2])
					classes = make([]base.Countable, class_count)
					class2option = make([][]bool, class_count)
				}
			case 1:
				{
					for i, v := range numbers {
						capacity, _ := strconv.Atoi(v)
						options[i].CId = base.CountableId{base.OptionType, i}
						options[i].Capacity = capacity
					}
				}
			case 2:
				{
					for i, v := range numbers {
						window, _ := strconv.Atoi(v)
						options[i].Window = window
					}
				}
			default:
				{
					num, _ := strconv.Atoi(numbers[0])
					classes[num].CId = base.CountableId{base.ClassType, num}
					class2option[num] = make([]bool, option_count)

					// find option with lowest slope
					// to determine capacity and windows

					classes[num].Capacity = 1
					classes[num].Window = 1
					slope := 1.0

					for i, v := range numbers {
						if i == 1 {
							demand, _ := strconv.Atoi(v)
							classes[num].Demand = demand
						} else if i > 1 {
							value, _ := strconv.Atoi(v)
							has_option := value == 1
							class2option[num][i-2] = has_option
							if has_option {
								options[i-2].Demand += classes[num].Demand
								slope2 := float64(options[i-2].Capacity) / float64(options[i-2].Window)
								if slope2 < slope {
									slope = slope2
									classes[num].Capacity = options[i-2].Capacity
									classes[num].Window = options[i-2].Window
								}
							}
						}
					}
				}
			}
			state++
		} else {
			//fmt.Println("c ", l)
		}
	}
	return

}
