package main

import (
	"../base"
	"flag"
	"fmt"
	"io/ioutil"
	"regexp"
	"strconv"
	"strings"
)

var solutionFile = flag.String("solution", "sol.txt", "Solution of a SAT solver; contains lines starting with s and model")
var symbolsFile = flag.String("symbols", "sym.txt", "Symbol file, must have syntax of the file generated by the encoder.")
var ver = flag.Bool("ver", false, "Prints version info.")

var digitRegexp = regexp.MustCompile("([0-9]+ )*[0-9]+")

func main() {
	flag.Parse()
	if *ver {
		fmt.Println(`CNF Decoder for solutions of the car sequencing problem from CSPLib 
Version tag: 0.2a
For infos about flags use -help
Copyright (C) NICTA and Valentin Mayer-Eichberger
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>
There is NO WARRANTY, to the extent permitted by law.`)
		return
	}

	// parse syntax file

	symbolTable, length, _, optionCount := parseSymboltable(*symbolsFile)

	// parse solution
	solution := parseSolution(*solutionFile)

	// generate pretty output

	cmatrix := make([]int, length)
	omatrix := make([][]int, length)

	for i, _ := range omatrix {
		omatrix[i] = make([]int, optionCount)
	}

	for _, x := range solution {
		if x > 0 {
			if entry, ok := symbolTable[x]; ok {
				if entry.CId.Typ == base.ClassType {
					cmatrix[entry.Pos] = entry.CId.Index
				} else if entry.CId.Typ == base.OptionType {
					omatrix[entry.Pos][entry.CId.Index] = 1
				}
			}
		}
	}

	for p := 0; p < length; p++ {
		fmt.Printf("%v\t",cmatrix[p])
		for j := 0; j < optionCount; j++ {
			fmt.Printf("%v ",omatrix[p][j])
		}
		fmt.Println()
	}

}

func parseSolution(filename string) (solution []int) {

	input, err := ioutil.ReadFile(filename)

	solution = make([]int, 0, 10000)

	if err != nil {
		fmt.Println("Please specifiy correct path to output of SAT solver if satisfiable. File does not exist: ", filename)
		return
	}

	lines := strings.Split(string(input), "\n")

	for _, l := range lines {
		l = strings.TrimSpace(l)
		if strings.HasPrefix(l, "v ") {
			lits := strings.Split(l, " ")
			for _, lit := range lits {
				if digitRegexp.MatchString(lit) {
					num, err := strconv.Atoi(lit)
					if err != nil {
						panic(err)
					}
					if num != 0 {
						solution = append(solution, num)
					}
				}
			}
		}
	}
	return
}

func parseSymboltable(filename string) (symbolTable map[int]base.PosVar, length, classSize, optionSize int) {

	symbolTable = make(map[int]base.PosVar, 10)

	input, err := ioutil.ReadFile(filename)

	if err != nil {
		fmt.Println("Please specifiy correct path to symboltable. File does not exist: ", filename)
		return
	}

	lines := strings.Split(string(input), "\n")

	for _, l := range lines {
		l = strings.Replace(l, " ", "", -1)
		l = strings.Replace(l, "\r", "", -1)
		l = strings.Replace(l, "\n", "", -1)
		l = strings.Replace(l, "\t", "", -1)

		//fmt.Println(l)

		elements := strings.Split(l, ":")

		if digitRegexp.MatchString(elements[0]) {
			if strings.HasPrefix(elements[1], "pos(") {
				l = elements[1][4:]
				l = l[:len(l)-1]
				id, _ := strconv.Atoi(elements[0])

				addItem := false
				var countType base.CountType

				if strings.HasPrefix(l, "class,") {
					addItem = true
					l = l[6:]
					countType = base.ClassType
				} else if strings.HasPrefix(l, "option,") {
					addItem = true
					l = l[7:]
					countType = base.OptionType
				}

				if addItem {
					numbers := strings.Split(l, ",")
					index, _ := strconv.Atoi(numbers[0])
					pos, _ := strconv.Atoi(numbers[1])
					length = max(length, pos+1)
					if countType == base.OptionType {
						optionSize = max(optionSize, index+1)
					} else if countType == base.ClassType {
						classSize = max(classSize, index+1)
					}
					posVar := base.PosVar{base.CountableId{countType, index}, pos}
					symbolTable[id] = posVar
				}
			}
		}
	}

	return
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}
