package main

import (
	"../base"
	"flag"
	"fmt"
	"io/ioutil"
	"regexp"
	"strconv"
	"strings"
)

var sol = flag.String("sol", "sol.txt", "Solution of a SAT solver; contains lines starting with s and model")
var sym = flag.String("sym", "sym.txt", "Symbol file, must have syntax of the file generated by the encoder.")
var ver = flag.Bool("ver", false, "Prints version info.")

var digitRegexp = regexp.MustCompile("([0-9]+ )*[0-9]+")

func main() {
	flag.Parse()
	if *ver {
		fmt.Println(`CNF Decoder for solutions of the car sequencing problem from CSPLib 
Version tag: 0.1a
For infos about flags use -help
Copyright (C) NICTA and Valentin Mayer-Eichberger
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>
There is NO WARRANTY, to the extent permitted by law.`)
		return
	}

	// parse syntax file

	//symbolTable := parseSymboltable(*sym)

	//fmt.Println(symbolTable)

	// parse solution
	parseSolution(*sol)

	// generate pretty output

}

func parseSolution(filename string) (solution []int) {

	input, err := ioutil.ReadFile(filename)

	if err != nil {
		fmt.Println("Please specifiy correct path to symboltable. File does not exist: ", filename)
		return
	}

	lines := strings.Split(string(input), "\n")

	for _, l := range lines {
		l = strings.TrimSpace(l)
		if strings.HasPrefix(l, "v ") {
			lits := strings.Split(l, " ")
			fmt.Println(l)
			for _, lit := range lits {
				if digitRegexp.MatchString(lit) {
					num, err := strconv.Atoi(lit)
					if err != nil {
						panic(err)
					}
					if num != 0 {
						fmt.Println(num)
					}
				}
			}
		}
	}

	return
}

func parseSymboltable(filename string) (symbolTable map[int]base.PosVar) {

	symbolTable = make(map[int]base.PosVar, 10)

	input, err := ioutil.ReadFile(filename)

	if err != nil {
		fmt.Println("Please specifiy correct path to symboltable. File does not exist: ", filename)
		return
	}

	lines := strings.Split(string(input), "\n")

	for _, l := range lines {
		l = strings.Replace(l, " ", "", -1)
		l = strings.Replace(l, "\r", "", -1)
		l = strings.Replace(l, "\n", "", -1)
		l = strings.Replace(l, "\t", "", -1)

		//fmt.Println(l)

		elements := strings.Split(l, ":")

		if digitRegexp.MatchString(elements[0]) {
			if strings.HasPrefix(elements[1], "pos(") {
				l = elements[1][4:]
				l = l[:len(l)-1]
				id, _ := strconv.Atoi(elements[0])

				addItem := false
				var countType base.CountType

				if strings.HasPrefix(l, "class,") {
					addItem = true
					l = l[6:]
					countType = base.ClassType

				} else if strings.HasPrefix(l, "option,") {
					addItem = true
					l = l[7:]
					countType = base.OptionType
				}

				if addItem {
					numbers := strings.Split(l, ",")
					index, _ := strconv.Atoi(numbers[0])
					pos, _ := strconv.Atoi(numbers[0])
					posVar := base.PosVar{base.CountableId{countType, index}, pos}
					symbolTable[id] = posVar
				}

			}
		}
	}

	return
}
